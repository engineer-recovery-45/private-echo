<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'unsafe-inline' https://cdn.tailwindcss.com https://cdn.jsdelivr.net https://unpkg.com; style-src 'unsafe-inline' https://cdn.tailwindcss.com; connect-src https://huggingface.co https://cdn-lfs.huggingface.co https://cdn-lfs-us-1.huggingface.co; worker-src blob:;">
    <title>PrivateEcho - AIボイス日記</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/dexie/dist/dexie.js"></script>
</head>
<body class="bg-slate-50 min-h-screen p-4 md:p-8 text-slate-800">

    <div class="max-w-2xl mx-auto space-y-8">
        <header class="text-center">
            <h1 class="text-3xl font-bold text-indigo-600">PrivateEcho</h1>
            <p class="text-slate-500">サーバー送信なし。あなたのデバイス内だけで完結するAI日記</p>
            <div id="modelInfo" class="mt-2 text-xs text-slate-400"></div>
        </header>

        <!-- 情報メッセージ表示エリア -->
        <div id="infoAlert" class="hidden bg-blue-50 border border-blue-200 text-blue-700 px-4 py-3 rounded-lg" role="alert">
            <div class="flex items-start">
                <span class="text-blue-500 mr-2">ℹ️</span>
                <div class="flex-1">
                    <p class="font-bold">お知らせ</p>
                    <p id="infoMessage" class="text-sm"></p>
                </div>
                <button id="closeInfo" class="text-blue-500 hover:text-blue-700 ml-2">&times;</button>
            </div>
        </div>

        <!-- エラーメッセージ表示エリア -->
        <div id="errorAlert" class="hidden bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded-lg" role="alert">
            <div class="flex items-start">
                <span class="text-red-500 mr-2">⚠️</span>
                <div class="flex-1">
                    <p class="font-bold">エラーが発生しました</p>
                    <p id="errorMessage" class="text-sm"></p>
                </div>
                <button id="closeError" class="text-red-500 hover:text-red-700 ml-2">&times;</button>
            </div>
        </div>

        <section class="bg-white p-6 rounded-2xl shadow-sm border border-slate-200">
            <div class="flex flex-col sm:flex-row items-center justify-between gap-4">
                <button id="recordBtn"
                        class="bg-red-500 hover:bg-red-600 disabled:bg-slate-300 disabled:cursor-not-allowed text-white px-6 py-3 rounded-full font-bold transition-all flex items-center gap-2 w-full sm:w-auto justify-center"
                        aria-label="録音ボタン">
                    <span id="recordIcon" class="w-3 h-3 bg-white rounded-full"></span>
                    <span id="recordText">録音開始</span>
                </button>
                <div id="status" class="text-sm text-slate-400 font-mono">Ready</div>
            </div>

            <!-- プログレスバー -->
            <div id="loadingBar" class="mt-4 hidden">
                <div class="flex justify-between text-xs text-slate-500 mb-1">
                    <span id="loadingText">処理中...</span>
                    <span id="loadingPercent">0%</span>
                </div>
                <div class="w-full bg-slate-100 rounded-full h-2 overflow-hidden">
                    <div id="progress" class="bg-indigo-500 h-full w-0 transition-all duration-300"></div>
                </div>
            </div>

            <!-- モデル選択（初回のみ表示） -->
            <div id="modelSelection" class="mt-4 hidden p-4 bg-slate-50 rounded-lg border border-slate-200">
                <p class="text-sm text-slate-600 mb-3">文字起こし方法を選択してください：</p>
                <div class="space-y-2">
                    <button id="selectAI" class="w-full text-left px-4 py-3 bg-white border border-indigo-300 rounded-lg hover:bg-indigo-50 transition-colors">
                        <div class="font-semibold text-indigo-600">🤖 AIモデル（オフライン対応）</div>
                        <div class="text-xs text-slate-500 mt-1">初回に40MB程度のダウンロードが必要。以降はオフラインで使用可能</div>
                    </button>
                    <button id="selectWebSpeech" class="w-full text-left px-4 py-3 bg-white border border-slate-300 rounded-lg hover:bg-slate-50 transition-colors">
                        <div class="font-semibold text-slate-700">🌐 ブラウザ標準機能（要インターネット）</div>
                        <div class="text-xs text-slate-500 mt-1">ダウンロード不要。常にインターネット接続が必要</div>
                    </button>
                </div>
            </div>
        </section>

        <!-- 日記エントリーリスト -->
        <div id="diaryList" class="space-y-4" role="list"></div>

        <!-- 空状態 -->
        <div id="emptyState" class="hidden text-center py-12">
            <div class="text-6xl mb-4">🎤</div>
            <p class="text-slate-400">まだ日記がありません</p>
            <p class="text-slate-400 text-sm mt-2">上の録音ボタンから始めましょう</p>
        </div>
    </div>

    <!-- 削除確認モーダル -->
    <div id="deleteModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
        <div class="bg-white rounded-lg p-6 max-w-sm w-full">
            <h3 class="text-lg font-bold mb-2">削除の確認</h3>
            <p class="text-slate-600 mb-4">この日記を削除しますか？この操作は取り消せません。</p>
            <div class="flex gap-3 justify-end">
                <button id="cancelDelete" class="px-4 py-2 rounded-lg border border-slate-300 hover:bg-slate-50">キャンセル</button>
                <button id="confirmDelete" class="px-4 py-2 rounded-lg bg-red-500 text-white hover:bg-red-600">削除する</button>
            </div>
        </div>
    </div>

    <script type="module">
        import { pipeline, env } from 'https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.2';

        // Transformers.jsの設定
        env.allowLocalModels = false;
        env.allowRemoteModels = true;

        // ============================================
        // 1. データベース設定 (Dexie)
        // ============================================
        const db = new Dexie("DiaryDB");
        db.version(2).stores({
            entries: '++id, date, text, timestamp',
            settings: 'key, value'
        });

        // ============================================
        // 2. アプリケーション状態管理
        // ============================================
        const AppState = {
            mediaRecorder: null,
            audioChunks: [],
            transcriber: null,
            recognition: null,
            isRecording: false,
            isProcessing: false,
            deleteTargetId: null,
            isModelLoaded: false,
            transcriptionMethod: null, // 'ai' or 'webspeech'
            modelLoadProgress: 0
        };

        // ============================================
        // 3. DOM要素の取得
        // ============================================
        const elements = {
            recordBtn: document.getElementById('recordBtn'),
            recordText: document.getElementById('recordText'),
            recordIcon: document.getElementById('recordIcon'),
            status: document.getElementById('status'),
            diaryList: document.getElementById('diaryList'),
            emptyState: document.getElementById('emptyState'),
            loadingBar: document.getElementById('loadingBar'),
            progress: document.getElementById('progress'),
            loadingText: document.getElementById('loadingText'),
            loadingPercent: document.getElementById('loadingPercent'),
            modelInfo: document.getElementById('modelInfo'),
            errorAlert: document.getElementById('errorAlert'),
            errorMessage: document.getElementById('errorMessage'),
            closeError: document.getElementById('closeError'),
            infoAlert: document.getElementById('infoAlert'),
            infoMessage: document.getElementById('infoMessage'),
            closeInfo: document.getElementById('closeInfo'),
            deleteModal: document.getElementById('deleteModal'),
            confirmDelete: document.getElementById('confirmDelete'),
            cancelDelete: document.getElementById('cancelDelete'),
            modelSelection: document.getElementById('modelSelection'),
            selectAI: document.getElementById('selectAI'),
            selectWebSpeech: document.getElementById('selectWebSpeech')
        };

        // ============================================
        // 4. ユーティリティ関数
        // ============================================

        // 情報表示
        function showInfo(message) {
            elements.infoMessage.textContent = message;
            elements.infoAlert.classList.remove('hidden');
        }

        // 情報非表示
        function hideInfo() {
            elements.infoAlert.classList.add('hidden');
        }

        // エラー表示
        function showError(message) {
            elements.errorMessage.textContent = message;
            elements.errorAlert.classList.remove('hidden');
            console.error('Error:', message);
        }

        // エラー非表示
        function hideError() {
            elements.errorAlert.classList.add('hidden');
        }

        // ローディング表示
        function showLoading(text = '処理中...') {
            elements.loadingBar.classList.remove('hidden');
            elements.loadingText.textContent = text;
            updateProgress(0);
        }

        // ローディング非表示
        function hideLoading() {
            elements.loadingBar.classList.add('hidden');
            updateProgress(0);
        }

        // プログレス更新
        function updateProgress(percent) {
            const smoothPercent = Math.min(Math.max(percent, 0), 100);
            elements.progress.style.width = `${smoothPercent}%`;
            elements.loadingPercent.textContent = `${Math.round(smoothPercent)}%`;
        }

        // ステータス更新
        function setStatus(text, isError = false) {
            elements.status.textContent = text;
            elements.status.className = isError
                ? 'text-sm text-red-500 font-mono'
                : 'text-sm text-slate-400 font-mono';
        }

        // ボタン状態更新
        function updateButtonState(isRecording) {
            AppState.isRecording = isRecording;

            if (isRecording) {
                elements.recordBtn.classList.remove('bg-red-500', 'hover:bg-red-600');
                elements.recordBtn.classList.add('bg-slate-600', 'hover:bg-slate-700');
                elements.recordText.textContent = '停止して保存';
                elements.recordIcon.classList.add('animate-pulse');
                setStatus('録音中...');
            } else {
                elements.recordBtn.classList.remove('bg-slate-600', 'hover:bg-slate-700');
                elements.recordBtn.classList.add('bg-red-500', 'hover:bg-red-600');
                elements.recordText.textContent = '録音開始';
                elements.recordIcon.classList.remove('animate-pulse');
            }
        }

        // ボタンの有効/無効切り替え
        function setButtonEnabled(enabled) {
            elements.recordBtn.disabled = !enabled;
        }

        // ============================================
        // 5. 設定の保存・読み込み
        // ============================================
        async function saveTranscriptionMethod(method) {
            await db.settings.put({ key: 'transcriptionMethod', value: method });
            AppState.transcriptionMethod = method;
        }

        async function loadTranscriptionMethod() {
            const setting = await db.settings.get('transcriptionMethod');
            return setting ? setting.value : null;
        }

        // ============================================
        // 6. AIモデルの初期化
        // ============================================
        async function initAI() {
            if (AppState.isModelLoaded && AppState.transcriber) return true;

            try {
                setStatus('AIモデルを読込中...');
                setButtonEnabled(false);
                showLoading('AIモデルを準備中...');

                // インポート元を @huggingface/transformers に変えるとより安定します
                AppState.transcriber = await pipeline(
                    'automatic-speech-recognition',
                    'onnx-community/whisper-tiny.en', // もしくは 'Xenova/whisper-tiny'
                    {
                        device: 'webgpu', // 可能ならGPUを使う（失敗時は自動でwasmにフォールバックされます）
                        progress_callback: (p) => {
                            if (p.status === 'progress') {
                                updateProgress(p.progress);
                            }
                        }
                    }
                );

                AppState.isModelLoaded = true;
                hideLoading();
                setStatus('AI Ready ✓');
                setButtonEnabled(true);
                return true;
            } catch (error) {
                console.error('Model loading error:', error);
                // ここで 'Unsupported model type' が出る場合、ライブラリのバージョンを疑ってください
                throw error;
            }
        }
        // ============================================
        // 7. Web Speech APIの初期化
        // ============================================
        function initWebSpeech() {
            try {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;

                if (!SpeechRecognition) {
                    throw new Error('お使いのブラウザは音声認識に対応していません');
                }

                AppState.recognition = new SpeechRecognition();
                AppState.recognition.lang = 'ja-JP';
                AppState.recognition.continuous = false;
                AppState.recognition.interimResults = false;
                AppState.recognition.maxAlternatives = 1;

                elements.modelInfo.textContent = '🌐 ブラウザ標準機能 (要ネット接続) ✓';
                setStatus('Ready');
                return true;

            } catch (error) {
                showError(`音声認識の初期化に失敗: ${error.message}`);
                return false;
            }
        }

        // ============================================
        // 8. 録音機能 (AIモデル使用)
        // ============================================
        async function startRecordingWithAI() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        channelCount: 1,
                        sampleRate: 16000,
                    }
                });

                AppState.mediaRecorder = new MediaRecorder(stream);
                AppState.audioChunks = [];

                AppState.mediaRecorder.ondataavailable = (e) => {
                    if (e.data.size > 0) {
                        AppState.audioChunks.push(e.data);
                    }
                };

                AppState.mediaRecorder.onstop = async () => {
                    stream.getTracks().forEach(track => track.stop());
                    await processRecordingWithAI();
                };

                AppState.mediaRecorder.onerror = (error) => {
                    showError(`録音エラー: ${error.message}`);
                    stopRecording();
                };

                AppState.mediaRecorder.start();
                updateButtonState(true);

            } catch (error) {
                handleMicrophoneError(error);
            }
        }

        async function processRecordingWithAI() {
            AppState.isProcessing = true;
            setButtonEnabled(false);

            try {
                setStatus('文字起こし中...');
                showLoading('音声を処理中...');
                updateProgress(10);

                if (AppState.audioChunks.length === 0) {
                    throw new Error('録音データがありません');
                }

                const audioBlob = new Blob(AppState.audioChunks, {
                    type: AppState.audioChunks[0].type
                });
                updateProgress(30);

                const arrayBuffer = await audioBlob.arrayBuffer();
                const audioData = new Uint8Array(arrayBuffer);

                updateProgress(50);

                console.log('Starting transcription...');
                const result = await AppState.transcriber(audioData, {
                    language: 'japanese',
                    task: 'transcribe',
                    chunk_length_s: 30,
                    stride_length_s: 5,
                    return_timestamps: false
                });

                console.log('Transcription result:', result);
                updateProgress(80);

                if (!result || !result.text || result.text.trim() === '') {
                    throw new Error('音声を認識できませんでした。もう一度お試しください。');
                }

                await saveEntry(result.text.trim());
                updateProgress(100);

                setStatus('完了！ ✓');
                hideLoading();
                setTimeout(() => setStatus('Ready'), 2000);

            } catch (error) {
                console.error('Processing error:', error);
                showError(`処理エラー: ${error.message}`);
                setStatus('処理失敗', true);
                hideLoading();
            } finally {
                AppState.isProcessing = false;
                setButtonEnabled(true);
                AppState.audioChunks = [];
            }
        }

        // ============================================
        // 9. 録音機能 (Web Speech API使用)
        // ============================================
        function startRecordingWithWebSpeech() {
            try {
                AppState.recognition.onstart = () => {
                    updateButtonState(true);
                    setStatus('録音中... (話してください)');
                };

                AppState.recognition.onresult = async (event) => {
                    const transcript = event.results[0][0].transcript;
                    console.log('Recognition result:', transcript);

                    if (transcript && transcript.trim()) {
                        setStatus('保存中...');
                        await saveEntry(transcript.trim());
                        setStatus('完了！ ✓');
                        setTimeout(() => setStatus('Ready'), 2000);
                    } else {
                        showError('音声を認識できませんでした');
                    }
                };

                AppState.recognition.onerror = (event) => {
                    console.error('Recognition error:', event.error);
                    updateButtonState(false);

                    if (event.error === 'no-speech') {
                        showError('音声が検出されませんでした。もう一度お試しください。');
                    } else if (event.error === 'network') {
                        showError('ネットワークエラー。インターネット接続を確認してください。');
                    } else {
                        showError(`音声認識エラー: ${event.error}`);
                    }
                    setStatus('Ready');
                };

                AppState.recognition.onend = () => {
                    updateButtonState(false);
                    if (!AppState.isProcessing) {
                        setStatus('Ready');
                    }
                };

                AppState.recognition.start();

            } catch (error) {
                showError(`音声認識の開始に失敗: ${error.message}`);
            }
        }

        function stopRecordingWithWebSpeech() {
            if (AppState.recognition) {
                AppState.recognition.stop();
            }
        }

        // ============================================
        // 10. 共通の録音制御
        // ============================================
        function stopRecording() {
            if (AppState.transcriptionMethod === 'ai') {
                if (AppState.mediaRecorder && AppState.mediaRecorder.state === 'recording') {
                    AppState.mediaRecorder.stop();
                    updateButtonState(false);
                }
            } else if (AppState.transcriptionMethod === 'webspeech') {
                stopRecordingWithWebSpeech();
            }
        }

        function handleMicrophoneError(error) {
            if (error.name === 'NotAllowedError') {
                showError('マイクへのアクセスが拒否されました。ブラウザの設定を確認してください。');
            } else if (error.name === 'NotFoundError') {
                showError('マイクが見つかりません。デバイスにマイクが接続されているか確認してください。');
            } else {
                showError(`録音の開始に失敗しました: ${error.message}`);
            }
            setStatus('録音失敗', true);
        }

        // ============================================
        // 11. データ保存
        // ============================================
        async function saveEntry(text) {
            await db.entries.add({
                date: new Date().toLocaleString('ja-JP', {
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit'
                }),
                timestamp: Date.now(),
                text: text
            });

            await renderDiaries();
        }

        // ============================================
        // 12. 日記の表示
        // ============================================
        async function renderDiaries() {
            try {
                const entries = await db.entries.orderBy('timestamp').reverse().toArray();

                if (entries.length === 0) {
                    elements.diaryList.classList.add('hidden');
                    elements.emptyState.classList.remove('hidden');
                    return;
                }

                elements.diaryList.classList.remove('hidden');
                elements.emptyState.classList.add('hidden');

                elements.diaryList.innerHTML = entries.map(entry => `
                        <div class="bg-white p-5 rounded-xl shadow-sm border border-slate-100 animate-fade-in hover:shadow-md transition-shadow" role="listitem">
                            <div class="flex justify-between items-start mb-3">
                                <div class="text-xs text-slate-400">${escapeHtml(entry.date)}</div>
                                <button
                                    class="delete-btn text-slate-400 hover:text-red-500 transition-colors p-1"
                                    data-id="${entry.id}"
                                    aria-label="削除"
                                    title="削除">
                                    🗑️
                                </button>
                            </div>
                            <p class="text-slate-700 leading-relaxed whitespace-pre-wrap">${escapeHtml(entry.text)}</p>
                        </div>
                    `).join('');

                document.querySelectorAll('.delete-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const id = parseInt(e.currentTarget.dataset.id);
                        showDeleteModal(id);
                    });
                });

            } catch (error) {
                showError(`日記の表示に失敗しました: ${error.message}`);
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // ============================================
        // 13. 削除機能
        // ============================================
        function showDeleteModal(id) {
            AppState.deleteTargetId = id;
            elements.deleteModal.classList.remove('hidden');
        }

        function hideDeleteModal() {
            AppState.deleteTargetId = null;
            elements.deleteModal.classList.add('hidden');
        }

        async function deleteEntry() {
            if (AppState.deleteTargetId === null) return;

            try {
                await db.entries.delete(AppState.deleteTargetId);
                await renderDiaries();
                hideDeleteModal();
                setStatus('削除しました');
                setTimeout(() => setStatus('Ready'), 2000);
            } catch (error) {
                showError(`削除に失敗しました: ${error.message}`);
            }
        }

        // ============================================
        // 14. イベントリスナーの設定
        // ============================================

        // 録音ボタン
        elements.recordBtn.addEventListener('click', async () => {
            if (AppState.isProcessing) return;

            // 文字起こし方法が未選択の場合、選択画面を表示
            if (!AppState.transcriptionMethod) {
                elements.modelSelection.classList.remove('hidden');
                showInfo('まず文字起こし方法を選択してください');
                return;
            }

            if (AppState.isRecording) {
                stopRecording();
            } else {
                hideError();
                hideInfo();

                if (AppState.transcriptionMethod === 'ai') {
                    if (!AppState.isModelLoaded) {
                        const success = await initAI();
                        if (!success) return;
                    }
                    await startRecordingWithAI();
                } else if (AppState.transcriptionMethod === 'webspeech') {
                    startRecordingWithWebSpeech();
                }
            }
        });

        // AIモデル選択
        elements.selectAI.addEventListener('click', async () => {
            elements.modelSelection.classList.add('hidden');
            hideInfo();
            await saveTranscriptionMethod('ai');
            const success = await initAI();
            if (success) {
                showInfo('AIモデルの読み込みが完了しました。録音ボタンを押して開始してください。');
                setTimeout(hideInfo, 3000);
            }
        });

        // Web Speech API選択
        elements.selectWebSpeech.addEventListener('click', async () => {
            elements.modelSelection.classList.add('hidden');
            hideInfo();
            await saveTranscriptionMethod('webspeech');
            const success = initWebSpeech();
            if (success) {
                showInfo('ブラウザ標準機能を使用します。録音ボタンを押して開始してください。');
                setTimeout(hideInfo, 3000);
            }
        });

        // アラートを閉じる
        elements.closeError.addEventListener('click', hideError);
        elements.closeInfo.addEventListener('click', hideInfo);

        // 削除モーダル
        elements.confirmDelete.addEventListener('click', deleteEntry);
        elements.cancelDelete.addEventListener('click', hideDeleteModal);

        elements.deleteModal.addEventListener('click', (e) => {
            if (e.target === elements.deleteModal) {
                hideDeleteModal();
            }
        });

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && !elements.deleteModal.classList.contains('hidden')) {
                hideDeleteModal();
            }
        });

        // ============================================
        // 15. 初期化
        // ============================================
        async function initialize() {
            try {
                await renderDiaries();

                // 保存された設定を読み込み
                const savedMethod = await loadTranscriptionMethod();

                if (savedMethod) {
                    AppState.transcriptionMethod = savedMethod;

                    if (savedMethod === 'ai') {
                        // バックグラウンドでモデルを読み込み（任意）
                        setStatus('Ready - AIモデル使用');
                        elements.modelInfo.textContent = '🤖 AIモデル (初回クリック時に読み込み)';
                    } else if (savedMethod === 'webspeech') {
                        initWebSpeech();
                    }
                } else {
                    // 初回起動時: 選択画面を表示
                    setStatus('Ready - 録音ボタンをクリックして開始');
                }

                // ブラウザの互換性チェック
                if (!window.MediaRecorder && !window.SpeechRecognition && !window.webkitSpeechRecognition) {
                    showError('お使いのブラウザは音声機能に対応していません。Chrome、Edge、Firefox等の最新版をお使いください。');
                }

            } catch (error) {
                showError(`初期化エラー: ${error.message}`);
            }
        }

        // アプリケーション起動
        initialize();
    </script>

    <style>
        @keyframes fade-in {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .animate-fade-in {
            animation: fade-in 0.4s ease-out forwards;
        }
    </style>
</body>
</html>