<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>PrivateEcho+ Emotion</title>
<script src="https://cdn.tailwindcss.com"></script>
<script src="https://unpkg.com/dexie/dist/dexie.js"></script>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&display=swap');
  body { font-family: 'Noto Sans JP', sans-serif; }
  .fade-in { animation: fade 0.4s ease-out; }
  @keyframes fade { from{opacity:0;transform:translateY(8px);} to{opacity:1;transform:translateY(0);} }
  .recording-pulse { animation: pulse 1.2s infinite; }
  @keyframes pulse { 0%,100%{opacity:1;} 50%{opacity:0.6;} }
  .dark-mode { background-color: #0f172a !important; color: #e2e8f0 !important; }
  .dark-mode .card { background-color: #1e293b !important; border-color: #334155 !important; }
  .dark-mode .text-slate-400 { color: #94a3b8 !important; }
  .dark-mode .text-slate-500 { color: #94a3b8 !important; }
  .loader {
    width: 18px; height: 18px;
    border: 2px solid #e2e8f0;
    border-top-color: #6366f1;
    border-radius: 50%;
    display: inline-block;
    animation: spin 0.7s linear infinite;
    vertical-align: middle;
    margin-right: 6px;
  }
  @keyframes spin { to { transform: rotate(360deg); } }
</style>
</head>

<body class="bg-slate-50 min-h-screen p-6 text-slate-800 transition-colors" id="body">

<div class="max-w-3xl mx-auto space-y-8">

  <header class="text-center space-y-2">
    <h1 class="text-3xl font-bold text-indigo-600">PrivateEcho+</h1>
    <p class="text-slate-500 text-sm">æ„Ÿæƒ…ãŒå¯è¦–åŒ–ã•ã‚Œã‚‹AIãƒœã‚¤ã‚¹æ—¥è¨˜</p>

    <div class="flex justify-center gap-4 mt-3">
      <button id="darkToggle" class="text-xs px-3 py-1 border rounded hover:bg-slate-100 transition-colors">ğŸŒ™ Dark</button>
      <button id="exportBtn" class="text-xs px-3 py-1 border rounded hover:bg-slate-100 transition-colors">ğŸ“ Markdown Export</button>
    </div>

    <div id="emotionSummary" class="text-xs text-slate-400 mt-2"></div>
  </header>

  <section class="card bg-white p-6 rounded-2xl shadow-sm border space-y-4">

    <!-- AI ãƒ¢ãƒ‡ãƒ«é¸æŠ -->
    <div class="flex items-center gap-3">
      <label class="text-sm font-medium text-slate-600 whitespace-nowrap">ãƒ¢ãƒ‡ãƒ«:</label>
      <select id="modelSelect" class="text-sm border rounded px-2 py-1 flex-1">
        <option value="Xenova/whisper-tiny">whisper-tinyï¼ˆé«˜é€Ÿãƒ»ä½ç²¾åº¦ï¼‰</option>
        <option value="Xenova/whisper-base">whisper-baseï¼ˆãƒãƒ©ãƒ³ã‚¹å‹ï¼‰</option>
        <option value="Xenova/whisper-small">whisper-smallï¼ˆé«˜ç²¾åº¦ãƒ»ä½é€Ÿï¼‰</option>
      </select>
      <button id="loadModelBtn" class="text-xs px-3 py-1 bg-indigo-500 text-white rounded hover:bg-indigo-600 transition-colors">
        èª­ã¿è¾¼ã¿
      </button>
    </div>

    <button id="recordBtn"
      class="bg-red-500 text-white px-6 py-3 rounded-full font-bold w-full hover:bg-red-600 transition-colors disabled:opacity-50"
      disabled>
      ğŸ™ éŒ²éŸ³é–‹å§‹
    </button>

    <div id="status" class="text-xs text-slate-400 text-center">ãƒ¢ãƒ‡ãƒ«ã‚’èª­ã¿è¾¼ã‚“ã§ãã ã•ã„</div>

    <!-- æ‰‹å‹•å…¥åŠ›ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ -->
    <details class="text-xs text-slate-400">
      <summary class="cursor-pointer hover:text-slate-600">âœï¸ ãƒ†ã‚­ã‚¹ãƒˆã§ç›´æ¥å…¥åŠ›ï¼ˆãƒã‚¤ã‚¯ãŒä½¿ãˆãªã„å ´åˆï¼‰</summary>
      <div class="mt-3 space-y-2">
        <textarea id="manualText" rows="3"
          class="w-full border rounded p-2 text-sm text-slate-700 resize-none"
          placeholder="æ—¥è¨˜ã®å†…å®¹ã‚’å…¥åŠ›..."></textarea>
        <button id="manualSaveBtn"
          class="text-xs px-4 py-2 bg-slate-600 text-white rounded hover:bg-slate-700 transition-colors">
          ä¿å­˜
        </button>
      </div>
    </details>

  </section>

  <div id="diaryList" class="space-y-4"></div>

</div>

<script>
// ================= DB =================
const db = new Dexie("DiaryDB_v2");
db.version(1).stores({
  entries: '++id, timestamp, text, emotion'
});

// ================= State =================
let recorder   = null;
let chunks     = [];
let transcriber = null;
let isRecording = false;
let aiReady    = false;
let isDark     = false;

// ================= DOM refs =================
const recordBtn   = document.getElementById("recordBtn");
const loadModelBtn = document.getElementById("loadModelBtn");
const modelSelect  = document.getElementById("modelSelect");
const statusEl    = document.getElementById("status");
const darkToggle  = document.getElementById("darkToggle");
const exportBtn   = document.getElementById("exportBtn");
const manualSaveBtn = document.getElementById("manualSaveBtn");
const manualText  = document.getElementById("manualText");

// ================= Emotion =================
function analyzeEmotion(text) {
  const positive = ["å¬‰ã—ã„","æ¥½ã—ã„","æœ€é«˜","è‰¯ã„","æˆåŠŸ","é”æˆ","å¥½ã","å¹¸ã›","ã‚ã‚ŠãŒã¨ã†","ç´ æ™´ã‚‰ã—ã„"];
  const negative = ["è¾›ã„","ç–²ã‚ŒãŸ","æœ€æ‚ª","å¤±æ•—","ä¸å®‰","å«Œã ","æ‚²ã—ã„","æ€–ã„","ç—›ã„","è‹¦ã—ã„","ãƒ€ãƒ¡"];
  let score = 0;
  positive.forEach(w => { if (text.includes(w)) score++; });
  negative.forEach(w => { if (text.includes(w)) score--; });
  if (score > 0) return "positive";
  if (score < 0) return "negative";
  return "neutral";
}

// ================= Render =================
async function render() {
  const entries = await db.entries.orderBy("timestamp").reverse().toArray();
  const list = document.getElementById("diaryList");
  list.innerHTML = "";

  if (entries.length === 0) {
    list.innerHTML = `<p class="text-center text-slate-400 py-8">ã¾ã æ—¥è¨˜ãŒã‚ã‚Šã¾ã›ã‚“</p>`;
    return;
  }

  let pos = 0, neg = 0, neu = 0;

  entries.forEach(e => {
    if (e.emotion === "positive") pos++;
    else if (e.emotion === "negative") neg++;
    else neu++;

    const emojiMap = { positive:"ğŸ˜Š", negative:"ğŸ˜¢", neutral:"ğŸ˜" };
    const colorMap = {
      positive: "bg-green-50 border-green-200",
      negative: "bg-red-50 border-red-200",
      neutral:  "bg-slate-50 border-slate-200"
    };
    const color = colorMap[e.emotion] || colorMap.neutral;

    const card = document.createElement("div");
    card.className = `card p-5 rounded-xl border ${color} fade-in`;
    card.innerHTML = `
      <div class="flex justify-between items-start mb-2">
        <span class="text-xs text-slate-400">${new Date(e.timestamp).toLocaleString("ja-JP")}</span>
        <span class="text-lg">${emojiMap[e.emotion] || "ğŸ˜"}</span>
      </div>
      <p class="whitespace-pre-wrap text-sm leading-relaxed">${escapeHtml(e.text)}</p>
      <button class="mt-3 text-xs text-red-400 hover:text-red-600" data-id="${e.id}">ğŸ—‘ å‰Šé™¤</button>
    `;
    card.querySelector("button").onclick = () => deleteEntry(e.id);
    list.appendChild(card);
  });

  document.getElementById("emotionSummary").innerText =
    `è¨˜éŒ²: ğŸ˜Š${pos}ä»¶ / ğŸ˜${neu}ä»¶ / ğŸ˜¢${neg}ä»¶`;
}

function escapeHtml(str) {
  return str.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;");
}

async function deleteEntry(id) {
  if (!confirm("ã“ã®æ—¥è¨˜ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ")) return;
  await db.entries.delete(id);
  render();
}

// ================= AI Init =================
async function initAI() {
  const modelName = modelSelect.value;
  loadModelBtn.disabled = true;
  loadModelBtn.innerHTML = '<span class="loader"></span>èª­è¾¼ä¸­...';
  setStatus("ğŸ”„ ãƒ¢ãƒ‡ãƒ«ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ä¸­... (åˆå›ã¯æ•°åˆ†ã‹ã‹ã‚Šã¾ã™)");
  recordBtn.disabled = true;

  try {
    // Dynamic import ã‚’ try-catch ã§å®‰å…¨ã«å®Ÿè¡Œ
    const { pipeline, env } = await import(
      'https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.2/dist/transformers.min.js'
    );

    // ãƒ–ãƒ©ã‚¦ã‚¶ã®ãƒ¡ã‚¤ãƒ³ã‚¹ãƒ¬ãƒƒãƒ‰ã§å®Ÿè¡Œï¼ˆWorkerä¸è¦ï¼‰
    env.allowLocalModels = false;
    env.useBrowserCache  = true;

    transcriber = await pipeline(
      'automatic-speech-recognition',
      modelName,
      { quantized: true }
    );

    aiReady = true;
    recordBtn.disabled = false;
    setStatus("âœ… AI Ready â€” éŒ²éŸ³ã‚’é–‹å§‹ã§ãã¾ã™");
    loadModelBtn.innerHTML = "âœ… å®Œäº†";
  } catch (err) {
    console.error("AI Load Error:", err);
    setStatus(`âŒ ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: ${err.message}`);
    loadModelBtn.disabled = false;
    loadModelBtn.innerHTML = "å†è©¦è¡Œ";
    alert(`ãƒ¢ãƒ‡ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚\n\nåŸå› : ${err.message}\n\nä»£ã‚ã‚Šã«ãƒ†ã‚­ã‚¹ãƒˆå…¥åŠ›ã‚’ã”åˆ©ç”¨ãã ã•ã„ã€‚`);
  }
}

// ================= Recording =================
async function startRecording() {
  if (!aiReady) {
    alert("å…ˆã«ãƒ¢ãƒ‡ãƒ«ã‚’èª­ã¿è¾¼ã‚“ã§ãã ã•ã„");
    return;
  }

  let stream;
  try {
    stream = await navigator.mediaDevices.getUserMedia({ audio: true });
  } catch (err) {
    alert(`ãƒã‚¤ã‚¯ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ãŒæ‹’å¦ã•ã‚Œã¾ã—ãŸã€‚\nãƒ–ãƒ©ã‚¦ã‚¶ã®è¨­å®šã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚\n\nã‚¨ãƒ©ãƒ¼: ${err.message}`);
    return;
  }

  // ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹mimeTypeã‚’é¸æŠ
  const mimeType = getSupportedMimeType();
  recorder = new MediaRecorder(stream, mimeType ? { mimeType } : {});
  chunks = [];

  recorder.ondataavailable = e => {
    if (e.data && e.data.size > 0) chunks.push(e.data);
  };

  recorder.onstop = async () => {
    stream.getTracks().forEach(t => t.stop());

    if (chunks.length === 0) {
      setStatus("âš ï¸ éŸ³å£°ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“");
      return;
    }

    setStatus("ğŸ”„ æ–‡å­—èµ·ã“ã—ä¸­...");

    try {
      const blob = new Blob(chunks, { type: recorder.mimeType || "audio/webm" });
      const arrayBuffer = await blob.arrayBuffer();
      const audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 16000 });
      const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

      // Float32Array ã«å¤‰æ›ï¼ˆWhisperãŒè¦æ±‚ã™ã‚‹å½¢å¼ï¼‰
      const channelData = audioBuffer.getChannelData(0);

      const result = await transcriber(channelData, {
        language: "japanese",
        task: "transcribe"
      });

      const text = (result.text || "").trim();

      if (!text) {
        setStatus("âš ï¸ éŸ³å£°ã‚’èªè­˜ã§ãã¾ã›ã‚“ã§ã—ãŸ");
        return;
      }

      const emotion = analyzeEmotion(text);
      await db.entries.add({ timestamp: Date.now(), text, emotion });
      setStatus("âœ… ä¿å­˜ã—ã¾ã—ãŸï¼");
      render();

    } catch (err) {
      console.error("Transcription error:", err);
      setStatus(`âŒ æ–‡å­—èµ·ã“ã—ã‚¨ãƒ©ãƒ¼: ${err.message}`);
    }
  };

  recorder.start(100); // 100ms ãƒãƒ£ãƒ³ã‚¯
  isRecording = true;
  recordBtn.innerHTML = "â¹ åœæ­¢ã—ã¦ä¿å­˜";
  recordBtn.classList.replace("bg-red-500", "bg-slate-600");
  recordBtn.classList.add("recording-pulse");
  setStatus("ğŸ™ éŒ²éŸ³ä¸­...");
}

function stopRecording() {
  if (recorder && recorder.state !== "inactive") {
    recorder.stop();
  }
  isRecording = false;
  recordBtn.innerHTML = "ğŸ™ éŒ²éŸ³é–‹å§‹";
  recordBtn.classList.replace("bg-slate-600", "bg-red-500");
  recordBtn.classList.remove("recording-pulse");
}

function getSupportedMimeType() {
  const types = [
    "audio/webm;codecs=opus",
    "audio/webm",
    "audio/ogg;codecs=opus",
    "audio/ogg",
    "audio/mp4"
  ];
  for (const type of types) {
    if (MediaRecorder.isTypeSupported(type)) return type;
  }
  return "";
}

// ================= Manual Input =================
manualSaveBtn.onclick = async () => {
  const text = manualText.value.trim();
  if (!text) { alert("ãƒ†ã‚­ã‚¹ãƒˆã‚’å…¥åŠ›ã—ã¦ãã ã•ã„"); return; }
  const emotion = analyzeEmotion(text);
  await db.entries.add({ timestamp: Date.now(), text, emotion });
  manualText.value = "";
  setStatus("âœ… ä¿å­˜ã—ã¾ã—ãŸï¼");
  render();
};

// ================= Export =================
async function exportMarkdown() {
  const entries = await db.entries.orderBy("timestamp").toArray();
  if (entries.length === 0) { alert("ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã™ã‚‹æ—¥è¨˜ãŒã‚ã‚Šã¾ã›ã‚“"); return; }

  let md = "# PrivateEcho+ Diary\n\n";
  entries.forEach(e => {
    md += `## ${new Date(e.timestamp).toLocaleString("ja-JP")} (${e.emotion})\n\n`;
    md += e.text + "\n\n---\n\n";
  });

  const blob = new Blob([md], { type: "text/markdown;charset=utf-8" });
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = `diary_${new Date().toISOString().slice(0,10)}.md`;
  a.click();
  setTimeout(() => URL.revokeObjectURL(a.href), 5000);
}

// ================= Dark Mode =================
darkToggle.onclick = () => {
  isDark = !isDark;
  document.body.classList.toggle("dark-mode", isDark);
  darkToggle.innerText = isDark ? "â˜€ï¸ Light" : "ğŸŒ™ Dark";
};

// ================= Events =================
loadModelBtn.onclick = initAI;

recordBtn.onclick = () => {
  if (isRecording) stopRecording();
  else startRecording();
};

exportBtn.onclick = exportMarkdown;

function setStatus(msg) {
  statusEl.innerText = msg;
}

// ================= Init =================
render();
</script>
</body>
</html>
